"""
Mage orchestrator integration for clgraph.

Converts clgraph pipelines to Mage pipeline files (metadata.yaml and block Python files).
Mage is a modern data pipeline tool with a notebook-style UI and block-based architecture.
"""

from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional

from .base import BaseOrchestrator

if TYPE_CHECKING:
    pass


class MageOrchestrator(BaseOrchestrator):
    """
    Converts clgraph pipelines to Mage pipelines.

    Mage uses a block-based architecture where each SQL query becomes a block
    (either data_loader or transformer). Dependencies are expressed via
    upstream_blocks and downstream_blocks.

    Example:
        from clgraph.orchestrators import MageOrchestrator

        orchestrator = MageOrchestrator(pipeline)
        files = orchestrator.to_pipeline_files(
            executor=execute_sql,
            pipeline_name="my_pipeline",
        )

        # Write files to Mage project
        import yaml
        with open("pipelines/my_pipeline/metadata.yaml", "w") as f:
            yaml.dump(files["metadata.yaml"], f)
        for name, code in files["blocks"].items():
            with open(f"pipelines/my_pipeline/{name}.py", "w") as f:
                f.write(code)
    """

    def to_pipeline_config(
        self,
        pipeline_name: str,
        description: Optional[str] = None,
        pipeline_type: str = "python",
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Generate Mage pipeline configuration (metadata.yaml content).

        Args:
            pipeline_name: Name for the Mage pipeline
            description: Optional pipeline description (auto-generated if not provided)
            pipeline_type: Pipeline type (default: "python")
            **kwargs: Additional configuration

        Returns:
            Dictionary representing metadata.yaml content
        """
        table_graph = self.table_graph

        if description is None:
            query_count = len(table_graph.queries)
            table_count = len(table_graph.tables)
            description = (
                f"Pipeline with {query_count} queries operating on "
                f"{table_count} tables. Generated by clgraph."
            )

        blocks = []
        for query_id in table_graph.topological_sort():
            query = table_graph.queries[query_id]
            block_name = self._sanitize_name(query_id)

            # Determine block type based on dependencies
            upstream_blocks = []
            for source_table in query.source_tables:
                if source_table in table_graph.tables:
                    table_node = table_graph.tables[source_table]
                    if table_node.created_by:
                        upstream_blocks.append(self._sanitize_name(table_node.created_by))

            block_config = {
                "name": block_name,
                "uuid": block_name,
                "type": "data_loader" if not upstream_blocks else "transformer",
                "upstream_blocks": upstream_blocks,
                "downstream_blocks": [],
            }
            blocks.append(block_config)

        # Set downstream_blocks for each block
        block_map = {b["name"]: b for b in blocks}
        for block in blocks:
            for upstream_name in block["upstream_blocks"]:
                if upstream_name in block_map:
                    block_map[upstream_name]["downstream_blocks"].append(block["name"])

        config = {
            "name": pipeline_name,
            "uuid": pipeline_name,
            "description": description,
            "type": pipeline_type,
            "blocks": blocks,
            **kwargs,
        }

        return config

    def to_blocks(
        self,
        executor: Callable[[str], None],
        connection_name: str = "clickhouse_default",
    ) -> Dict[str, str]:
        """
        Generate Mage block Python files.

        Args:
            executor: Function that executes SQL (for code reference)
            connection_name: Name of database connection in Mage io_config.yaml

        Returns:
            Dictionary mapping block_name -> block_code
        """
        table_graph = self.table_graph
        blocks = {}

        for query_id in table_graph.topological_sort():
            query = table_graph.queries[query_id]
            block_name = self._sanitize_name(query_id)

            # Determine upstream blocks
            upstream_blocks = []
            for source_table in query.source_tables:
                if source_table in table_graph.tables:
                    table_node = table_graph.tables[source_table]
                    if table_node.created_by:
                        upstream_blocks.append(self._sanitize_name(table_node.created_by))

            # Determine block type
            block_type = "data_loader" if not upstream_blocks else "transformer"

            # Generate block code
            code = self._generate_block_code(
                block_name=block_name,
                block_type=block_type,
                sql=query.sql,
                query_id=query_id,
                upstream_blocks=upstream_blocks,
                connection_name=connection_name,
            )

            blocks[block_name] = code

        return blocks

    def _generate_block_code(
        self,
        block_name: str,
        block_type: str,
        sql: str,
        query_id: str,
        upstream_blocks: List[str],
        connection_name: str,
    ) -> str:
        """Generate Python code for a Mage block."""

        # Mage requires specific function names for each block type
        if block_type == "data_loader":
            decorator = "@data_loader"
            func_name = "load_data"
            imports = "from mage_ai.data_preparation.decorators import data_loader"
        else:
            decorator = "@transformer"
            func_name = "transform"
            imports = "from mage_ai.data_preparation.decorators import transformer"

        # Build function signature
        if upstream_blocks:
            args = ", ".join([f"data_{i}" for i in range(len(upstream_blocks))])
            func_args = f"({args}, *args, **kwargs)"
        else:
            func_args = "(*args, **kwargs)"

        # Escape triple quotes in SQL if present
        escaped_sql = sql.replace('"""', '\\"\\"\\"')

        code = f'''"""
Block: {block_name}
Query ID: {query_id}
Type: {block_type}
Generated by clgraph
"""
{imports}
from mage_ai.io.clickhouse import ClickHouse


{decorator}
def {func_name}{func_args}:
    """
    Execute SQL query in ClickHouse.
    """
    sql = """
{escaped_sql}
"""

    with ClickHouse.with_config(config_profile="{connection_name}") as loader:
        loader.execute(sql)

    return {{"status": "success", "query_id": "{query_id}"}}
'''
        return code

    def to_pipeline_files(
        self,
        executor: Callable[[str], None],
        pipeline_name: str,
        description: Optional[str] = None,
        connection_name: str = "clickhouse_default",
    ) -> Dict[str, Any]:
        """
        Generate complete Mage pipeline file structure.

        Args:
            executor: Function that executes SQL (for code reference)
            pipeline_name: Name for the Mage pipeline
            description: Optional pipeline description
            connection_name: Database connection name in Mage io_config.yaml

        Returns:
            Dictionary with file structure:
            {
                "metadata.yaml": <dict>,
                "blocks": {
                    "block1.py": <code>,
                    "block2.py": <code>,
                }
            }
        """
        config = self.to_pipeline_config(
            pipeline_name=pipeline_name,
            description=description,
        )

        blocks = self.to_blocks(
            executor=executor,
            connection_name=connection_name,
        )

        return {
            "metadata.yaml": config,
            "blocks": blocks,
        }


__all__ = ["MageOrchestrator"]
